'use strict';

/**
 * 캔버스에서 애니메이션 구현은 어떻게 할까?
 * 
 * 캔버스는 무조건 그림이다.
 * 그럼 공을 하나 그렸을 때, 그게 날아가는 애니메이션을 그리려면 어떻게 해야할까?
 * 
 * 애니메이션은 공의 위치가 순차적으로 옆으로 옮겨지면 그게 연결되서 보이는 게 애니메이션!
 * 그럼 처음 공을 빠르게 지우고서 옆에 공을 다시 그리고, 그걸 또 지우고 다시 옆에 그리고 이런 식으로 하는 걸
 * 빠르게 돌리면 마치 공이 움직이는 것처럼 보임.
 * 
 * 캔버스 애니메이션은 이런 과정을 직접 만들어줘야 하는 것
 * css와 달리 굳이 캔버스가 아니더라도 js로 뭔가를 움직이게 만들려면 이렇게 해야 함.
 * 뭔가 반복적으로 계속 실행해주면서 우리가 움직이길 원하는 개체의 좌표를 바꿔주는 거. 계산을 통해서!
 * 
 * 애니메이션 라이브러리들이 그런 계산같은 걸 직접 안해도 되게끔 알아서 내부적으로 코드가 짜여있는 것.
 */
const canvas = document.querySelector('.canvas');
const context = canvas.getContext('2d');

let xPos = 10;
// 수평 이동 애니메이션을 만들거기 때문에, x position값을 갱신할 수 있도록 변수를 선언함.

// 이제 애니메이션 만들때는 앞에서 말했듯이 그리기를 반복해야 하니까
// 그리는 과정을 아예 하나의 함수로 만들거임.
function draw(){
  // 함수를 시작할 때마다 이전 프레임을 지워주려는 거임. 어느 영역을 지운다? 캔버스 판 전체를 싹 지우고 다시 시작!
  context.clearRect(0, 0, canvas.width, canvas.height); // 이렇게 하면 지우기 그리기가 계속 반복되는 거
  context.beginPath(); // 얘는 뭘 그리던 절대 빼먹으면 안됨ㅠ 이걸 안쓰면 애니메이션이 문제가 생긴다.
  context.arc(xPos, 150, 10, 0, Math.PI * 2, false); // 참고로 360도 = Math.PI * 2 이거는 그냥 외워두는 게 좋다.
  context.fill();
  // console.log('draw'); 콘솔에 찍어보면 엄청 빠른 속도로 draw함수가 계속 호출되고 있다는 걸 알 수 있음.

  xPos += 1; 
  // xPos = xPos + 3; 과 같음.
  // xPos값을 반복할 때마다 3씩 늘려준다는 뜻. 
  // 근데 또 요렇게만 하고 끝내면 애니메이션이 작동하기는 하는데
  // 우리가 원하는 공이 날라가는 느낌이 아니라 선이 그려짐. 왜일까? 앞에 그린 원을 안지워줘서!
  // 그러니까 매번 실행할 때마다 지워주면 되겠지? 뭐를? 이전 프레임의 전체영역을 지워버려야 함!

  requestAnimationFrame(draw); 
  // 자 그럼 이런식으로 인위적으로 반복을 수행해서 애니메이션을 만들어주려면?
  // 함수가 반복될 때마다 원의 좌표값을 바꿔주면 되겠지!
  // 그냥 이 상태로 해버리면 처음 그린 곳에 똑같은 걸 엄청 빠른 속도로 계속 똑같이 그려주기만 하는 것.
  // 엄청 빠른 속도가 어느 정도냐면, 기본적으로 이 메소드는 1/60초를 목표로 함. 즉, 60fps인 셈.
  // '목표' 라는 말은 그 속도가 보장은 안된다는 뜻. 디스플레이 및 기기의 성능이나 상태에 따라 더 느릴수도 있음. 
}

  /**
 * requestAnimationFrame()
 * 
 * 이제 이걸 반복해야 되는데, 뭐로 하냐면 requestAnimationFrame() 이라는 걸 사용해서 반복을 시켜줌.
 * 
 * 얘는 리플로우, 리페인트라는 개념을 먼저 알면 좋음.
 * 리플로우: 브라우저가 화면을 그려낼 때 크기, 위치 등의 설정을 계산으로 맞추어가는 과정
 * 리페인트: 리플로우에서 계산된 결과를 가지고 우리가 눈에 보일 수 있도록 색깔을 칠해주는 과정 -> 결국 색칠이 되야 우리 눈에 보이겠지
 * requestAnimationFrame() 얘는 리페인트를 하기 전, 이렇게 색칠을 할 준비가 다 되었는지 기다려주는 아이임.
 * 
 * 원래 예전에는 계산이 다 끝내기도 전에 색칠을 하라고 브라우저가 명령해서 브라우저가 버벅거리기도 했음.
 * 왜냐면 애니메이션은 많은 그림들을 빨리 그려내야 하는데, 계산이 다 되기도 전에 색칠해버리라고 하니까 문제가 되는거지
 * 그래서 이 메소드는 색칠할 준비가 최적화될 때까지 계산을 기다려주는 메소드라고 보면 됨. 
 * 이렇게 하면 뭐가 좋은가? 프레임이 유실되거나 끊겨보이거나 버벅대는 현상이 많이 완화되는 장점이 있음.
 * 
 * 기본적으로 이 메소드 자체가 뭔가를 반복시켜주는 아이는 아님.
 * 단지, 한 번 그려줄 때, 최적화될 때까지 기다렸다가 그리기 좋은 상태가 되었을 때 그려주는 애임.
 * 이 때, 이 메소드를 이용해서 '인위적으로' 반복을 시켜주는 거임.
 */
// requestAnimationFrame(draw); 
// 이런식으로 parameter 자리에 그림을 그려주는 함수를 전달해주면 됨
// 이렇게 하면 바로 draw가 실행되는 게 아니라, 그릴 준비가 완료가 되었을 때 draw를 실행시킴
// 이렇게 그림 그려주는 함수 블록 바깥에서 호출해주면 한 번만 그려주겠지만,
// 이 메소드를 블록 안에서 호출한 상태에서 블록 바깥에서는 그림 그려주는 함수를 호출하면 그릴 준비가 되었을 때 그려주는 과정을 무한 반복실행함.
// 함수가 자기 안에서 자기를 호출하는 무한 반복과정. 이게 아까 말한 '인위적으로' 반복시켜주는 것.
// 이 draw()함수 자체는 1개의 프레임인 것. 이 함수를 실행하는 것 자체가 1개의 프레임을 그려주는 것. 이라고 보면 됨.
draw();

